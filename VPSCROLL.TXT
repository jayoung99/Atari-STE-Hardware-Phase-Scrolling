;        1         2         3         4         5         6         7         8
;2345678901234567890123456789012345678901234567890123456789012345678901234567890
;*******************************************************************************

                     Vertical Phase Scrolling Methodology
                               by Jeffrey Young

=================
Table of Contents
=================

  Introduction

  Infinite Scrolling
    Screen
    Tiles
    Level Map

  Scanwrap Scrolling
    Memory Layout
    Tile Scanlines
    Scanwrap Lines
    Scanwrap Tile Lines
    Scanwrap Screen
    Playfield Buffer
    Ram View
    Operation
    Splits

  Phase Scrolling
    Phases
    Normalization
    Normalizing Speed
    Normalizing Orientation
    Normalizing Phase
    Directional Changes
    Speed Changes
    Phase Compensation
    Phase Completion
    Fill Gauge


===================
Topic:Introduction
===================

This text file is a supplement to the Atari STE phase scroll demo VPSCROLL.TOS.

https://github.com/jayoung99/Atari-STE-Hardware-Phase-Scrolling

It is meant to provide the methodology behind vertical phase scrolling and
topics of application.

It does not attempt to document how to program STE hardware or the phase scroll
algorithm. The source code for the demo VPSCROLL.S is fully commented and
provides a good foundation for that.

For technical details of the STE features used in the demo, below are some
recommended resources:

Atari STE FAQ
https://www.atari-wiki.com/index.php?title=Atari_STE_FAQ_compiled_by_The_Paranoid_/_Paradox

Blitter FAQ
https://www.atari-wiki.com/index.php?title=The_Atari_ST(E)_BLiTTER_in_brief_by_The_Paranoid_of_Paradox_2012

For jumping straight to a topic you can use the search function of your text
editor. Each section starts with the keyword 'Topic:' followed by the topic
name from the Table of Contents. So, for example, to jump immediately to the
section on phase scrolling search for 'Topic:Phase Scrolling' without the
single quotes.


========================
Topic:Infinite Scrolling
========================

Infinite scrolling is a tile-based scrolling technique used to provide the
illusion of continuous, never-ending graphics movement across a background
displayed on the physical screen. Typically it is used for game levels in
conjunction with a tile graphics data set and level map.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Tiles
See Topic:Level Map
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


============
Topic:Screen
============

The graphics display of the STE in low resolution is dimensionally 320x200
pixels and will be referred to as the 'screen'. This is represented in ram in
planar format to accommodate the 16 color output of the shifter chip.

This example will use a screen height of 160 lines instead of the full 200.
This would leave 40 lines unused on-screen, but is just for example purposes as
160 will divide evenly into the 'tile' size as will be seen below.

                            .---pixels 0-319
                            |
 .--------------------------------------------------------.
 |                                                        |
 v                                                        v
+-----------------------------------------------------------+
|                                                           |<---.
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                     Display Screen                        |    |
|                                                           |    |---lines 0-159
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |    |
|                                                           |<---'
+-----------------------------------------------------------+


===========
Topic:Tiles
===========

Tiles are an abstraction of graphics data represented as 'blocks' that are
'imprinted' into the display screen ram in much the same manner as a rubber
stamp would be impressed onto a piece of paper to transfer its image.

Tiles in this example are 16x16, 4-plane graphics data blocks that are stored
contiguously in memory separate from the screen ram. Each tile requires 128
bytes as explained below for the 4-plane format used by the STE:

                          16-pixel tile line (8 bytes)
                                   |
  .-----------------------------------------------------------------.
  |                                                                 |
  v                                                                 v
      plane 0          plane 1          plane 2          plane 3
     (2 bytes)        (2 bytes)        (2 bytes)        (2 bytes)
 |................|................|................|................| line 0
 |................|................|................|................| line 1
 |................|................|................|................| line 2
 |................|................|................|................| line 3
 |................|................|................|................| line 4
 |................|................|................|................| line 5
 |................|................|................|................| line 6
 |................|................|................|................| line 7
 |................|................|................|................| line 8
 |................|................|................|................| line 9
 |................|................|................|................| line 10
 |................|................|................|................| line 11
 |................|................|................|................| line 12
 |................|................|................|................| line 13
 |................|................|................|................| line 14
 |................|................|................|................| line 15

 8*16 = 128 bytes

Displayed on-screen, tiles appear like this:

   .---16 pixels
   |
.-----.
|     |
v     v
+-----+ <---.
|     |     |
|tile |     |---16 lines
|     |     |
+-----+ <---'

20 of these tiles will exactly fit along the display screen width and 10 will
fit along the height of the screen forming a series of 'columns' and 'rows'.

                            .---columns 0-19
                            |
 .--------------------------------------------------------.
 |                                                        |
 v                                                        v
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|<---.
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t|                    | t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+   Display Screen   +--+--+--+--+--+--+--+    |
| t| t| t| t| t| t|                    | t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+       (Tiles)      +--+--+--+--+--+--+--+    |---rows 0-9
| t| t| t| t| t| t|                    | t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+    |
| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t| t|<---'
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

There are 200 tiles in the above example. Some of these tiles could be identical
to others, as let's say, the lowest row might represent grass which could be
made up of identical graphics data, repeated along the width of the screen.

+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|<---row 9
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

In this case, it would be inefficient to store 20 identical graphics data blocks
in memory which would require 128*20 = 2560 bytes. Instead, it would be better
to store only one 128 byte graphics block and have a way to point to it when
copying graphics data into the screen ram. This is the idea of a 'level map'.


===============
Topic:Level Map
===============

Since each tile requires 128 bytes, the complete tile graphics data block can
be seen as an indexable contiguous series of these 128 byte blocks.

   tile 0---.       tile 1---.     tile 2---.      tile 3---.       etc..
            |                |              |               |
            v                v              v               v
   |-- 128 bytes --|-- 128 bytes --|-- 128 bytes --|-- 128 bytes --|.......

The level map is a multi-dimensional array defined in columns and rows or x,y.
The array elements contain values that indicate which tile graphics data block
to use for any particular tile position on the display screen. Below is an
example level map for a 20x10 static screen where every tile would display
the tile 0 graphics data block.

The elements in this level map array are byte-sized constraining the indices to
a value between 0-255. This would dictate a maximum of 256 distinct tiles that
could be referenced in any particular tile graphics data block.

level_map:
;columns
;      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 1
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 2
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 3
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 4
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 5
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 6
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 7
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 8
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;row 9
;                  (describes 20x10 tile static screen)

Extending the previous example of a screen display tile row with each tile in
the row being the identical graphics data representing grass we can say that
tile 2 contains the graphics data for a 'grass' tile. The level map would then
reflect this in the last 20 bytes with the value 2 in each element of the 'row'.

   tile 0---.       tile 1---.     tile 2---.      tile 3---.       etc..
            |                |              |               |
            v                v              v               v
   |-- 128 bytes --|-- 128 bytes --|-- 128 bytes --|-- 128 bytes --|.......
                                            ^
                                            |
                                         +--+
                                         |~~|
                                         +--+
                                     'grass' tile
                                     graphics data

 level_map:
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 dc.b  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 <---row 9
       ^                                                        ^
       |                                                        |
       '--------------------------------------------------------'
                                   |
                  use 'grass' tile 2 for the entire row
                                   |
                                   |
                                   v
     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     |~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|~~|<---row 9
     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                          displayed on-screen

Using this concept, the ram required to store tile graphics data for an entire
row of identical tiles has been reduced from 128*20 = 2560 bytes down to just
128*1 + 20 = 148 bytes. Further, this savings in memory usage increases the more
times a tile is referenced in the level map.

That explains the basic concept of a level map, with the caveat that so far,
the examples have described the level map for a static screen.

Extending this idea to allow infinite scrolling throughout a larger, virtual
'level' uses the exact same principles except the level map column and row
dimensions are increased as needed to describe the extents of the level.

level_map:
;columns
;      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 0
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 1
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 2
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 3
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 4
 ...
 ...
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 95
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 96
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 97
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 98
 dc.b  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;row 99
;                (describes 20x100 tile scrollable level)


========================
Topic:Scanwrap Scrolling
========================

Scanwrap scrolling is a technique for vertical, so-called infinite scrolling,
which is tile-based using a 'level map' with indices in each element that
indicates which tile graphics block to use for each playfield position. The
playfield screen is thus built upon columns and rows of such tiles.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Infinite Scrolling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This method of vertical scrolling can be either uni- or bi-directional with
uni-directional scrolling needing a slightly smaller scanwrap playfield buffer
as well as being marginally faster to process.

As an example, a level map describing 100 vertical rows of tiles with a screen
width of 20 tiles would require 100*20=2000 bytes to store the map. This is for
tile graphics data sets with a maximum number of 256 tiles so that each element
of the level map can be byte-sized. Each index would then be in the range
of 0-255.

With each tile's display size being 16x16 this would require 128 bytes for
every tile in the set using the 4-plane graphics format of the STE.  For a 256
element tile set this would require 256*128 = 32768 bytes total.
~~~~~~~~~~~~~~~
See Topic:Tiles
~~~~~~~~~~~~~~~

The scanwrap scrolling technique uses a wrap-around ring-style buffer which can
be split into 2 sections when drawing the screen. This method requires
additional hidden rows in the buffer layout to provide space to update or
'fill-in' upcoming tile data during times of fine-scrolling so that these
update rows are ready to be used as playfield display rows by the time a coarse
scroll is needed and the physical screen pointer updated. This method of
infinite vertical scrolling requires a smaller total buffer size than some other
scrolling techniques to achieve the same effect.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Memory Layout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


===================
Topic:Memory Layout
===================

The scanwrap playfield buffer is logically constructed in memory as shown below.
Details of each component is described in individual topics that follow.

 scanwrap memory layout - logical view

 buffer start ---> uuuuuuuuuuuuuuuuuuuu             -------------------------
 visible start---> tttttttttttttttttttt             | u = update row        |
                   tttttttttttttttttttt             | t = playfield row     |
                   tttttttttttttttttttt             | s = fine scroll row   |
                   tttttttttttttttttttt             -------------------------
                   tttttttttttttttttttt
                   tttttttttttttttttttt
                   tttttttttttttttttttt
                   tttttttttttttttttttt
                   tttttttttttttttttttt
                   tttttttttttttttttttt <---visible end
                   ssssssssssssssssssss
                   uuuuuuuuuuuuuuuuuuuu <---buffer end

It is important to remember that the above is solely a logical representation
and the actual buffer in memory is a continuous block of bytes as shown below.

 scanwrap memory layout - contiguous view

uuuuuuuuuuuuuuuuuuuutttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssss
uuuuuuuuuuuuuuuuuuuu

While this logical view represents the scanwrap playfield buffer at the start,
at run-time usage of the buffer will move the rows' positions as conditions
change and wrap-around about itself. This is solely a logical function. The
memory buffer itself is not changed but rather is logically handled as if it
had been by use of pointers and variables.
~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Playfield Buffer
~~~~~~~~~~~~~~~~~~~~~~~~~~


====================
Topic:Tile Scanlines
====================

The scanwrap playfield buffer is logically comprised of tiles, each 16x16.

Since the tiles are 16 pixels in width, for the 4-plane graphics format of the
STE each line of the tiles height (a 'tile scanline') requires 8 bytes.

                     16-pixel tile scanline (8 bytes)
                                   |
  .-----------------------------------------------------------------.
  |                                                                 |
  v                                                                 v
      plane 0          plane 1          plane 2          plane 3
     (2 bytes)        (2 bytes)        (2 bytes)        (2 bytes)
 |................|................|................|................|

  2*4 = 8 bytes


====================
Topic:Scanwrap Lines
====================

A scanwrap line is comprised of tile scanline segments, each requiring a certain
number of bytes. Since there are 20 tiles horizontally this requires 160 bytes.

                     .---playfield tiles scanlines - 160 bytes
                     |
 .---------------------------------------.
 |               20 tiles                |
 v                                       v
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|

  8*20 = 160 bytes


=========================
Topic:Scanwrap Tile Lines
=========================

Each tile is 16 scanlines in height so 16 scanwrap lines is equivalent to what
can be called a scanwrap 'tile line'.


                      .---playfield tile lines - 2560 bytes
                      |
 .---------------------------------------.
 |                                       |
 v                                       v
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|<---.
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |---16 scanwrap lines
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |    1 scanwrap tile line
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|    |
 |8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|8|<---'

  16*(8*20) = 2560 bytes

Conceptually, a scanwrap tile line will be described in this way:

                     .---20 playfield tiles
                     |
 .---------------------------------------.
 |                                       |
 v                                       v
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|<---1 scanwrap tile line

  16*160 = 2560 bytes


=====================
Topic:Scanwrap Screen
=====================

For our example scanwrap layout, 160 vertical screen lines is equivalent to
10 scanwrap tile lines. This is the minimum to display on screen with no
scrolling.

                     .---20 playfield columns
                     |
 .---------------------------------------.
 |                                       |
 v                                       v
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|<---.
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |--- 10 scanwrap tile lines
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |     1 scanwrap screen
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|<---'

  10*2560 = 25600 bytes


======================
Topic:Playfield Buffer
======================

In addition to the memory required for the scanwrap screen, three initially
hidden rows are required for the scrolling technique and added together
comprise the total scanwrap playfield buffer space required.

                     .---20 playfield columns
                     |
 .---------------------------------------.
 |                                       |
 v                                       v
 |U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|<---top update row
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|<---.
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |--- 10 scanwrap tile lines
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |     1 scanwrap screen
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    |
 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|<---'
 |S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<---fine scroll row
 |U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|U|<---bottom update row

  13*2560 = 33280 bytes

Of course scanwrap scrolling doesn't mandate 10 tiles vertically or really
any specific screen height. However, the 'phase scrolling' derivative which
is the subject of this project does require the screen to be a multiple of
16x16 tiles. And so any screen height from 1-12 tiles would work with this
method but each would require different buffer sizes.

Below are some examples:

                    (bi-directional)
 Playfield Height | Vertical Tiles | Scanwrap Buffer Size
        152               9              30720 bytes
        160              10              33280 bytes
        176              11              35840 bytes
        192              12              38400 bytes

The above requirements are for bi-directional vertical scrolling. For
uni-directional vertical scrolling one of the update rows can be eliminated
requiring less memory for the buffer as shown below:

                    (uni-directional)
 Playfield Height | Vertical Tiles | Scanwrap Buffer Size
        152               9              28160 bytes
        160              10              30720 bytes
        176              11              33280 bytes
        192              12              35840 bytes


=======================
Topic:Scanwrap Ram View
=======================

As each row or 'tile line' of the playfield buffer takes 2560 bytes, we can
bring the logical view of the playfield buffer out a bit further as a ram view.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Scanwrap Tile Lines
See Topic:Scanwrap Playfield Buffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    scanwrap ram view - logical view

 start of buffer ---> |    2560 bytes    |
  screen address ---> |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    |
                      |    2560 bytes    | <--- end of screen display
                      |    2560 bytes    |
                      |    2560 bytes    | <--- end of buffer


And then knowing that the buffer is really just a continuous block of system
ram, the view can be expressed this way:

    scanwrap ram view - contiguous view


   .--- start of buffer - byte 0
   |
   |    .--- screen address - byte 2560
   |    |
   v    v
  |.............................. 33280 bytes .............................|
                                                                     ^    ^
                                                                     |    |
                          end of screen display byte - byte 25599 ---'    |
                                                                          |
                                            end of buffer - byte 33279 ---'


========================
Topic:Scanwrap Operation
========================

To describe the scanwrap buffer technique, we'll walkthrough a simple sequence
of coarse scrolls downwards to show how the buffer wraps around itself as the
movement progresses.
~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Memory Layout
See Topic:Scanwrap Ram View
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The function of the update rows row are detailed in the section on phase
scrolling, but suffice to say they are filled in with tile graphics data as
the fine scroll advances and then are used as new display rows as they are
brought into range of the shifter as it builds the display screen.

The address the shifter uses to start displaying screen graphics is advanced
forwards or backwards as the scrolling proceeds. This effectively changes
the starting tile line or row that the scanwrap routine works with. Since
the buffer is a wrap-around or ring-type buffer, this changes the logical
representation of the buffer which requires the buffer handling to also change.
~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Phase Scrolling
~~~~~~~~~~~~~~~~~~~~~~~~~

    scanwrap playfield buffer - logical view        -------------------------
                                                    | u = update row        |
 start of buffer ---> uuuuuuuuuuuuuuuuuuuu          | t = playfield row     |
   display start ---> tttttttttttttttttttt          | s = fine scroll row   |
                      tttttttttttttttttttt          -------------------------
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt <--- last display row
                      ssssssssssssssssssss
                      uuuuuuuuuuuuuuuuuuuu <--- end of buffer

                               |
                               |  scroll down 1 row
                               v

 start of buffer ---> uuuuuuuuuuuuuuuuuuuu
                      uuuuuuuuuuuuuuuuuuuu
   display start ---> tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt <--- last display row
                      ssssssssssssssssssss <--- end of buffer

From this we can see the physical buffer remains the same continuous block
of bytes in system ram, but the representation of where the logical rows are
has changed. If the scrolling progress downwards 2 more rows we see this:

 start of buffer ---> tttttttttttttttttttt <--- last display row
                      ssssssssssssssssssss
                      uuuuuuuuuuuuuuuuuuuu
                      uuuuuuuuuuuuuuuuuuuu
   display start ---> tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt <--- end of buffer

Here we see the last tile row to be display on-screen has wrapped-around to
the bytes at the beginning of the buffer. Since the shifter starts at the
"display start" row and pushes a continuous stream of bytes to the display, it
would not know where the last display row was and would simple display that row
from the undefined space past the end of the buffer.

 start of buffer ---> tttttttttttttttttttt <--- last display row
                      ssssssssssssssssssss
                      uuuuuuuuuuuuuuuuuuuu
                      uuuuuuuuuuuuuuuuuuuu
   display start ---> tttttttttttttttttttt <--- shifter begins
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt
                      tttttttttttttttttttt <--- end of buffer
                      xxxxxxxxxxxxxxxxxxxx <--- !!SHIFTER DISPLAYS GARBAGE!!

This is solved through the use of 'scanwrap split' which is discussed below.


=====================
Topic:Scanwrap Splits
=====================

The shifter of the STE can be programmed to display screen graphics from an
arbitrary location on-the-fly, even during the screen draw itself. By using
a timer b interrupt in event count mode, the playfield can be 'split' at any
specific screen line and different parts of the playfield buffer can be
displayed in the proper order and position.

To show this more clearly, a series of examples are given below which correlate
the logical view of the playfield buffer at different stages of scrolling with
the actual screen display drawn by the shifter. This represents where and why
splits are required.

*-------------------------------------------------------------------------------
Ex) After initialization, no scroll has occurred and the display is contiguous.
    The shifter can push the ten display screen tile lines 0-9 in one swoop
    without requiring a split.

          logical view                  physical screen
      uuuuuuuuuuuuuuuuuuuu          +--------------------+
      tttttttttttttttttttt ---.     |                    |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt    |---> |       320x160      | <---no split required
      tttttttttttttttttttt    |     |    10 tile lines   |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt    |     |                    |
      tttttttttttttttttttt ---'     |                    |
      ssssssssssssssssssss          +--------------------+
      uuuuuuuuuuuuuuuuuuuu

*-------------------------------------------------------------------------------
Ex) The playfield has been scrolled down 3 rows. This results in rows 4-12
    being contiguous at the bottom of the scanwrap buffer to be used for
    the fist nine display screen tile lines 0-8 but the last display screen
    tile line will require a split. If the shifter simply continued on from the
    bottom row of the buffer memory, there would be invalid ram pushed to the
    display screen. We need to tell the shifter to use the screen address at
    the top of the scanwrap buffer for the last tile line on the screen.
    This is the essence of the scanwrap technique.

          logical view
 .--- tttttttttttttttttttt
 |    ssssssssssssssssssss
 |    uuuuuuuuuuuuuuuuuuuu              physical screen
 |    uuuuuuuuuuuuuuuuuuuu          +--------------------+
 |    tttttttttttttttttttt ---.     |                    |
 |    tttttttttttttttttttt    |     |                    |
 |    tttttttttttttttttttt    |     |                    |
 |    tttttttttttttttttttt    |     |      320x144       |
 |    tttttttttttttttttttt    |---> |    9 tile lines    |
 |    tttttttttttttttttttt    |     |                    |
 |    tttttttttttttttttttt    |     |                    |
 |    tttttttttttttttttttt    |     |                    |
 |    tttttttttttttttttttt ---'     |--------------------| <---split required
 '--------------------------------> |  320x16 tile line  |
                                    +--------------------+

*-------------------------------------------------------------------------------
Ex) The playfield has been scrolled down 12 rows. This leaves only row 12
    available for the shifter to use for the first tile line of the display
    screen. A split is required to tell the shifter to push the rest of the
    screen data from the top of the scanwrap buffer.

          logical view
   .- tttttttttttttttttttt
   |  tttttttttttttttttttt
   |  tttttttttttttttttttt
   |  tttttttttttttttttttt
 .-|  tttttttttttttttttttt
 | |  tttttttttttttttttttt
 | |  tttttttttttttttttttt
 | |  tttttttttttttttttttt
 | '- tttttttttttttttttttt
 |    ssssssssssssssssssss
 |    uuuuuuuuuuuuuuuuuuuu              physical screen
 |    uuuuuuuuuuuuuuuuuuuu          +--------------------+
 |    tttttttttttttttttttt -------> |  320x16 tile line  |
 |                            .---> |--------------------| <---split required
 |                            |     |                    |
 |                            |     |                    |
 |                            |     |                    |
 '----------------------------|     |      320x144       |
                              |     |    9 tile lines    |
                              |     |                    |
                              |     |                    |
                              '---> |                    |
                                    +--------------------+

*-------------------------------------------------------------------------------


=====================
Topic:Phase Scrolling
=====================

Phase scrolling as presented here is an application of the scanwrap tile-based
'infinite' vertical scrolling technique for the Atari STE which attempts to
smooth out the drawing of update row data while also allowing changes in
scrolling speed. To this end, phase scrolling uses the full STE screen width
of 320 pixels based on a multiple of 16x16 graphics tiles. These 4-plane
graphics blocks build the playfield display based on a level map which indicates
which tile is to be used in which playfield position.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Infinite Scrolling
See Topic:Scanwrap Scrolling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hence, a playfield with 320 horizontal display pixels would be 20 tiles wide
(as each tile is 16 pixels in width).

The idea behind this implementation is that of having 16 fine-scroll intervals
available to copy and 'fill-in' data into the update rows before a coarse
scroll and screen address change. Having the screen width at a fixed multiple of
16 means that each fine-scroll interval (i.e. phase) has a fixed number of lines
to copy to the update buffer. Lines here being tile scanlines.
~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Tile Scanlines
~~~~~~~~~~~~~~~~~~~~~~~~

For example with a 320 pixel playfield, each phase will need to only fill in
20 lines of the update row - called a phase block. The phase block can consist
of one or more, full or partial row tiles depending on the phase and speed.
This results in a consistent workload and therefore helps to smooth out the cpu
time required for completing the entire update row.

This concept also allows a method of speed changes to work smoothly around the
core idea. There are 8 speeds in phase scrolling: 1,2,4,8,-1,-2,-4 and -8
(with 0 being no scroll) and each speed reflects the number of lines which
will be fine-scrolled. Using these discrete speed values, which all go into 16
themselves allows the phases to be scaled up and down with the phase blocks
expanding and shrinking in width in-phase with speed changes.

There are several concepts to be considered regarding STE phase scrolling.
Each will be described in the following topics.


============
Topic:Phases
============

Phases are the part of the fine-scrolling interval where the work of copying
tile graphics data into the update row for the next coarse scroll is done in
such a way that the work is composed of consistent and even segments called
phase blocks.
~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Memory Layout
~~~~~~~~~~~~~~~~~~~~~~~

Below are diagrams of the phases and their constituent phase blocks with respect
to the available speeds based on playfield width of 320 lines or 20 tiles. For
speed 1, phase blocks are 20 lines each phase and consist of 2 full or partial
row tiles so that when the last phase is complete the update row is entirely
filled and ready to be used for the visible playfield. This happens in sync with
the fine-scrolling since there are 16 fine-scroll positions and 16 phases.
Negative speeds are handled the same as their positive counterparts.

When increasing the speed, the work involved filling the update row per phase
is naturally higher and so the phase block width also increases. For speed 2,
40 lines of tile graphics data have to be copied per phase and the number of
phases to complete the update row is reduced to 8 since we are now moving at
twice the speed. Speed 4 needs 80 lines filled-in per phase with 4 phases and
speed 8 needs 160 tile scanlines per phase with only two phases per update row
fill. For this project the phase blocks are copied to the update row with the
STE blitter chip in hog mode to optimize speed.

================================================================================
Speed 1

    .---update row tile lines drawn per phase
    |
    +---------+---------+---------+---------+---------+---------+---------+----.
    |         |         |         |         |         |         |         |    |
.-------. .-------. .-------. .-------. .-------. .-------. .-------. .-------.|
|phase 0| |phase 1| |phase 2| |phase 3| |phase 4| |phase 5| |phase 6| |phase 7||
|-------| |-------| |-------| |-------| |-------| |-------| |-------| |-------||
|16   4 | |12   8 | | 8  12 | | 4  16 | |16   4 | |12   8 | | 8  12 | | 4  16 ||
'-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-'|
  v   v     v   v     v   v     v   v     v   v     v   v     v   v     v   v  |
+---+---+     +---+     +---+     +---+ +---+---+     +---+     +---+     +---+|
| 0 | 1 |     | 2 |     | 3 |     | 4 | | 5 | 6 |     | 7 |     | 8 |     | 9 ||
|   |     |   |   |     |   |     |   | |   |     |   |   |     |   |     |   ||
|   |     |   |     |   |   |     |   | |   |     |   |     |   |   |     |   ||
|   |     | 1 |     | 2 |     | 3 |   | |   |     | 6 |     | 7 |     | 8 |   ||
+---+     +---+     +---+     +---+---+ +---+     +---+     +---+     +---+---+|
                                                                               |
    .---------+---------+---------+---------+---------+---------+---------+----'
    |         |         |         |         |         |         |         |
.-------. .-------. .-------. .-------. .-------. .-------. .-------. .-------.
|phase 8| |phase 9| |phase10| |phase11| |phase12| |phase13| |phase14| |phase15|
|-------| |-------| |-------| |-------| |-------| |-------| |-------| |-------|
|16   4 | |12   8 | | 8  12 | | 4  16 | |16   4 | |12   8 | | 8  12 | | 4  16 |
'-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-' '-|---|-'
  v   v     v   v     v   v     v   v     v   v     v   v     v   v     v   v
+---+---+     +---+     +---+     +---+ +---+---+     +---+     +---+     +---+
|10 |11 |     |12 |     |13 |     |14 | |15 |16 |     |17 |     |18 |     |19 |
|   |     |   |   |     |   |     |   | |   |     |   |   |     |   |     |   |
|   |     |   |     |   |   |     |   | |   |     |   |     |   |   |     |   |
|   |     |11 |     |12 |     |13 |   | |   |     |16 |     |17 |     |18 |   |
+---+     +---+     +---+     +---+---+ +---+     +---+     +---+     +---+---+

================================================================================
Speed 2

      .---update row tile lines drawn per phase
      |
      +-------------------+-------------------+-------------------+------------.
      |                   |                   |                   |            |
.-----------.       .-----------.       .-----------.       .-----------.      |
|  phase 0  |       |  phase 2  |       |  phase 4  |       |  phase 6  |      |
|-----------|       |-----------|       |-----------|       |-----------|      |
|16  16   8 |       | 8  16  16 |       |16  16   8 |       | 8  16  16 |      |
'-|---|---|-'       '-|---|---|-'       '-|---|---|-'       '-|---|---|-'      |
  v   v   v           v   v   v           v   v   v           v   v   v        |
+---+---+---+           +---+---+       +---+---+---+           +---+---+      |
| 0 | 1 | 2 |           | 3 | 4 |       | 5 | 6 | 7 |           | 8 | 9 |      |
|   |   |   |           |   |   |       |   |   |   |           |   |   |      |
|   |   |           |   |   |   |       |   |   |           |   |   |   |      |
|   |   |           | 2 |   |   |       |   |   |           | 7 |   |   |      |
+---+---+           +---+---+---+       +---+---+           +---+---+---+      |
                                                                               |
      .-------------------+-------------------+-------------------+------------'
      |                   |                   |                   |
.-----------.       .-----------.       .-----------.       .-----------.
|  phase 8  |       |  phase 10 |       |  phase 12 |       |  phase 14 |
|-----------|       |-----------|       |-----------|       |-----------|
|16  16   8 |       | 8  16  16 |       |16  16   8 |       | 8  16  16 |
'-|---|---|-'       '-|---|---|-'       '-|---|---|-'       '-|---|---|-'
  v   v   v           v   v   v           v   v   v           v   v   v
+---+---+---+           +---+---+       +---+---+---+           +---+---+
|10 |11 |12 |           |13 |14 |       |15 |16 |17 |           |18 |19 |
|   |   |   |           |   |   |       |   |   |   |           |   |   |
|   |   |           |   |   |   |       |   |   |           |   |   |   |
|   |   |           |12 |   |   |       |   |   |           |17 |   |   |
+---+---+           +---+---+---+       +---+---+           +---+---+---+

================================================================================
Speed 4

           .---update row tile lines drawn per phase
          |
          +---------------------------------------+----------------------------.
          |                                       |                            |
.-------------------.                   .-------------------.                  |
|      phase 0      |                   |      phase 4      |                  |
|-------------------|                   |-------------------|                  |
|16  16  16  16  16 |                   |16  16  16  16  16 |                  |
'-|---|---|---|---|-'                   '-|---|---|---|---|-'                  |
  v   v   v   v   v                       v   v   v   v   v                    |
+---+---+---+---+---+                   +---+---+---+---+---+                  |
| 0 | 1 | 2 | 3 | 4 |                   | 5 | 6 | 7 | 8 | 9 |                  |
|   |   |   |   |   |                   |   |   |   |   |   |                  |
|   |   |   |   |   |                   |   |   |   |   |   |                  |
|   |   |   |   |   |                   |   |   |   |   |   |                  |
+---+---+---+---+---+                   +---+---+---+---+---+                  |
                                                                               |
          .---------------------------------------+----------------------------'
          |                                       |
.-------------------.                   .-------------------.
|      phase 8      |                   |      phase 12     |
|-------------------|                   |-------------------|
|16  16  16  16  16 |                   |16  16  16  16  16 |
'-|---|---|---|---|-'                   '-|---|---|---|---|-'
  v   v   v   v   v                       v   v   v   v   v
+---+---+---+---+---+                   +---+---+---+---+---+
|10 |11 |12 |13 |14 |                   |15 |16 |17 |18 |19 |
|   |   |   |   |   |                   |   |   |   |   |   |
|   |   |   |   |   |                   |   |   |   |   |   |
|   |   |   |   |   |                   |   |   |   |   |   |
+---+---+---+---+---+                   +---+---+---+---+---+

================================================================================
Speed 8

                     .---update row tile lines drawn per phase
                    |
                    +----------------------------------------------------------.
                    |                                                          |
.---------------------------------------.                                      |
|                phase 0                |                                      |
|---------------------------------------|                                      |
|16  16  16  16  16  16  16  16  16  16 |                                      |
'-|---|---|---|---|---|---|---|---|---|-'                                      |
  v   v   v   v   v   v   v   v   v   v                                        |
+---+---+---+---+---+---+---+---+---+---+                                      |
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |                                      |
|   |   |   |   |   |   |   |   |   |   |                                      |
|   |   |   |   |   |   |   |   |   |   |                                      |
|   |   |   |   |   |   |   |   |   |   |                                      |
+---+---+---+---+---+---+---+---+---+---+                                      |
                                                                               |
                    .----------------------------------------------------------'
                    |
.---------------------------------------.
|                phase 8                |
|---------------------------------------|
|16  16  16  16  16  16  16  16  16  16 |
'-|---|---|---|---|---|---|---|---|---|-'
  v   v   v   v   v   v   v   v   v   v
+---+---+---+---+---+---+---+---+---+---+
|10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |
|   |   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+
================================================================================

For another way to look at phases and phase blocks, the following tables break
down the relationship between the fine-scroll intervals and the phases. Again
with a 20 tile wide 320 pixel playfield screen.

+-----------------------------------------------------------------------------+
| speed = 1            y-pos   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |
|                              |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
| phase 0  --------------------'  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
| phase 1  -----------------------'  |  |  |  |  |  |  |  |  |  |  |  |  |  | |
| phase 2  --------------------------'  |  |  |  |  |  |  |  |  |  |  |  |  | |
| phase 3  -----------------------------'  |  |  |  |  |  |  |  |  |  |  |  | |
| phase 4  --------------------------------'  |  |  |  |  |  |  |  |  |  |  | |
| phase 5  -----------------------------------'  |  |  |  |  |  |  |  |  |  | |
| phase 6  --------------------------------------'  |  |  |  |  |  |  |  |  | |
| phase 7  -----------------------------------------'  |  |  |  |  |  |  |  | |
| phase 8  --------------------------------------------'  |  |  |  |  |  |  | |
| phase 9  -----------------------------------------------'  |  |  |  |  |  | |
| phase 10 --------------------------------------------------'  |  |  |  |  | |
| phase 11 -----------------------------------------------------'  |  |  |  | |
| phase 12 --------------------------------------------------------'  |  |  | |
| phase 13 -----------------------------------------------------------'  |  | |
| phase 14 --------------------------------------------------------------'  | |
| phase 15 -----------------------------------------------------------------' |
+-----------------------------------------------------------------------------+
| At this speed, fine-scroll changes are at 1 line intervals.                 |
| Here every position change will draw 1/16 of the update row.                |
| There are 16 phases and phase blocks consist of 20 tile scanlines.          |
+-----------------------------------------------------------------------------+

+-----------------------------------------------------------------------------+
| speed = 2            y-pos   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |
|                              |     |     |     |     |     |     |     |    |
| phase 0  --------------------'     |     |     |     |     |     |     |    |
| phase 1                            |     |     |     |     |     |     |    |
| phase 2  --------------------------'     |     |     |     |     |     |    |
| phase 3                                  |     |     |     |     |     |    |
| phase 4  --------------------------------'     |     |     |     |     |    |
| phase 5                                        |     |     |     |     |    |
| phase 6  --------------------------------------'     |     |     |     |    |
| phase 7                                              |     |     |     |    |
| phase 8  --------------------------------------------'     |     |     |    |
| phase 9                                                    |     |     |    |
| phase 10 --------------------------------------------------'     |     |    |
| phase 11                                                         |     |    |
| phase 12 --------------------------------------------------------'     |    |
| phase 13                                                               |    |
| phase 14 --------------------------------------------------------------'    |
| phase 15                                                                    |
+-----------------------------------------------------------------------------+
| At this speed, fine-scroll changes are at 2 line intervals.                 |
| Here every position change will draw 1/8 of the update row.                 |
| There are 8 phases and phase blocks consist of 40 tile scanlines.           |
+-----------------------------------------------------------------------------+

+-----------------------------------------------------------------------------+
| speed = 4            y-pos   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |
|                              |           |           |           |          |
| phase 0  --------------------'           |           |           |          |
| phase 1                                  |           |           |          |
| phase 2                                  |           |           |          |
| phase 3                                  |           |           |          |
| phase 4  --------------------------------'           |           |          |
| phase 5                                              |           |          |
| phase 6                                              |           |          |
| phase 7                                              |           |          |
| phase 8  --------------------------------------------'           |          |
| phase 9                                                          |          |
| phase 10                                                         |          |
| phase 11                                                         |          |
| phase 12 --------------------------------------------------------'          |
| phase 13                                                                    |
| phase 14                                                                    |
| phase 15                                                                    |
+-----------------------------------------------------------------------------+
| At this speed, fine-scroll changes are at 4 line intervals.                 |
| Here every position change will draw 1/4 of the update row.                 |
| There are 4 phases and phase blocks consist of 80 tile scanlines.           |
+-----------------------------------------------------------------------------+

+-----------------------------------------------------------------------------+
| speed = 8            y-pos   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |
|                              |                       |                      |
| phase 0  --------------------'                       |                      |
| phase 1                                              |                      |
| phase 2                                              |                      |
| phase 3                                              |                      |
| phase 4                                              |                      |
| phase 5                                              |                      |
| phase 6                                              |                      |
| phase 7                                              |                      |
| phase 8  --------------------------------------------'                      |
| phase 9                                                                     |
| phase 10                                                                    |
| phase 11                                                                    |
| phase 12                                                                    |
| phase 13                                                                    |
| phase 14                                                                    |
| phase 15                                                                    |
+-----------------------------------------------------------------------------+
| At this speed, fine-scroll changes are at 8 line intervals.                 |
| Here every position change will draw 1/2 of the update row.                 |
| There are 2 phases and phase blocks consist of 160 tile scanlines.          |
+-----------------------------------------------------------------------------+


===================
Topic:Normalization
===================

Phase scrolling has a few variables that can be normalized for smaller and more
efficient code.  Normalization in the sense of altering the natural state of
some variables that are common to the method but may have different aspects
based on run-time conditions.

The three values that are normalized are:
 - speed
 - update row orientation
 - phase

These are discussed in the following topics.


=======================
Topic:Normalizing Speed
=======================

Speed is normalized to an absolute value since the phase processing is the same
whether the speed is positive or negative. Speed polarity *can* determine which
update row is used, but only on a row change which would be the result of a
coarse scroll. A separate coarse scroll flag is used for this purpose. During
inter-row speed changes this does not come into play.
~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Speed Changes
~~~~~~~~~~~~~~~~~~~~~~~

 Ex) natural speed       normalized speed
          1                     1
          2                     2
          4                     4
          8                     8
         -8                     8
         -4                     4
         -2                     2
         -1                     1


=============================
Topic:Normalizing Orientation
=============================

The update row orientation is normalized to always use a 0->15 phase block
progression. For understanding why this might be needed, here are examples with
both up and down scrolling.

Downward scrolling causes the y-position values to increase and so also the
fine-scroll values increase as well. For speed 1 the progression goes as this:
-----------------------------------------------------
y-position 0 --> construct update row phase block 0
y-position 1 --> construct update row phase block 1
...
...
y-position 14 --> construct update row phase block 14
y-position 15 --> construct update row phase block 15
-----------------------------------------------------

Upward scrolling causes the y-position values to decrease and so also the
fine-scroll values decrease as well. So when going from one row to a
previous one at speed 1, the progression goes like this:
--------------------------------------------------------
y-position 15 --> construct update row phase block 15
y-position 14 --> construct update row phase block 14
...
...
y-position 1 --> construct update row phase block 1
y-position 0 --> construct update row phase block 0
--------------------------------------------------------

So by default, the construction of the update row progresses from 0->15
when scrolling down and from 15->0 when scrolling up. This requires some
additional code to handle the differences especially with regards to gap
detection and updating the fill gauge which is avoided with normalization.
~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Speed Changes
See Topic:Fill Gauge
~~~~~~~~~~~~~~~~~~~~~~~

Ex)
                          top update row phases
                         .-----------------------------------------------.
             .---------> | 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15|
             |           '-----------------------------------------------'
 scroll up   |                 builds from end to start <----------------
             |
            ---   (natural)
             |
 scroll down |            -----------------> builds from start to end
             |           .-----------------------------------------------.
             '---------> | 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15|
                         '-----------------------------------------------'
                          bottom update row phases


                          top update row phases
                         .-----------------------------------------------.
             .---------> | 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15|
             |           '-----------------------------------------------'
 scroll up   |            -----------------> builds from start to end
             |
            ---   (normalized)
             |
 scroll down |            -----------------> builds from start to end
             |           .-----------------------------------------------.
             '---------> | 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15|
                         '-----------------------------------------------'
                          bottom update row phases


=======================
Topic:Normalizing Phase
=======================

Normalizing the phase is helpful in situations where the speed changes from 1
to a higher speed. Since speed 1 can be any phase 0-15 and is equal to the
current y-position's fine-scroll value, then when a speed increase happens, the
resulting y-position can cause an out-of-phase condition. Normalization brings
the y-position back in-phase with regards to the speed no matter the value.

Ex)
----------------------------------------------------------------
speed 1
                           screen lines
                            ---
                      .--->  .
                      |--->  .
                      |--->  .
                      |--->  . <---+-- y-position 3
                      |--->  .     |
                      |--->  .     '-- natural phase block
                      |--->  .
valid phase blocks ---|--->  .
      (0-15)          |--->  .
                      |--->  .    (natural and in-phase)
                      |--->  .
                      |--->  .
                      |--->  .
                      |--->  .
                      |--->  .
                      '--->  .
                            ---
----------------------------------------------------------------

----------------------------------------------------------------
speed increases to 4
                           screen lines
                            ---
                      .--->  .
                      |      .
                      |      .
                      |      .
                      |--->  .
                      |      .
                      |      .
valid phase blocks ---|      . <---+-- y-position 7
   (0, 4, 8, 12)      |--->  .     |
                      |      .     '-- natural phase block
                      |      .
                      |      .
                      '--->  .
                             .    (natural and out-of-phase)
                             .
                             .
                            ---

Here we see with the speed increase to 4, the natural phase
block changes to 7 which is not an allowed phase for that speed.
Although it lies 'within' the boundary of the valid phase block
it is 'out-of-phase'.
----------------------------------------------------------------

----------------------------------------------------------------
speed increases to 4
                           screen lines
                            ---
                      .--->  .
                      |      .
                      |      .
                      |      .
                      |--->  . <------ normalized phase block
                      |      .
                      |      .
valid phase blocks ---|      . <------ y-position 7
   (0, 4, 8, 12)      |--->  .
                      |      .
                      |      .
                      |      .
                      '--->  .
                             .    (normalized and in-phase)
                             .
                             .
                            ---

Here the phase has been normalized and this results in an
'in-phase' condition.
----------------------------------------------------------------


=========================
Topic:Directional Changes
=========================

There are two types of directional changes in phase scrolling. The first is
simply a change of sign for the speed value and is separate from the actual
scroll direction. Consider this sequence:

 ______________________________________
| speed = 0
| scroll direction = downward (default)
| ---
|  . <--- y-position 0
|  .
|  .        _____________________________
|  .       | speed = 1
|  .       | scroll direction = downward
|  .       | ---
|  .       |  .
|  .       |  . <--- y-position 1
|  .       |  .
|  .       |  .
|  .       |  .        ____________________________
|  .       |  .       | speed = -1
|  .       |  .       | scroll direction = downward
|  .       |  .       | ---
|  .       |  .       |  . <--- y-position 0
|  .       |  .       |  .
| ---      |  .       |  .
           |  .       |  .
           |  .       |  .
           |  .       |  .
           |  .       |  .
           |  .       |  .
           | ---      |  .
                      |  .
                      |  .
                      |  .
                      |  .
                      |  .
                      |  .
                      |  .
                      | ---

You might ask why the scroll direction is still downward even though the
y-position has moved upward due to the negative speed. The answer is that this
is a 'inter-row' y-position change and so is detached from scroll direction
changes. So even though the y-position went up, we are still in the same
screen row and so will still use the current update row which is the bottom one.

In phase scrolling the only time the scroll direction value might change is
when an actual row change occurs. And if the row change causes a scroll
direction value change, the update row that is used will also be changed.

Key to understanding this is to know that when the playfield is first drawn
*both* the top update row and scroll row are filled in so that scrolling
may happen in either direction at the start.
~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Playfield Buffer
~~~~~~~~~~~~~~~~~~~~~~~~~~

A sequence is presented to further illustrate the idea:

--------------------------------------------------------------------------------
step 1 - initial playfield draw - starting level map tile 22 speed 1

At start we need to display tile rows 22-31 from the level map.
Shown with accompanying update and scroll rows.

 |uuuuuuuuuuuuuuuuuuuu| <--- top update row
 |tttttttttttttttttttt| <--- playfield row 0 ---> (level map tile row 22)
 |tttttttttttttttttttt| <--- playfield row 1 ---> (level map tile row 23)
 |tttttttttttttttttttt| <--- playfield row 2 ---> (level map tile row 24)
 |tttttttttttttttttttt| <--- playfield row 3 ---> (level map tile row 25)
 |tttttttttttttttttttt| <--- playfield row 4 ---> (level map tile row 26)
 |tttttttttttttttttttt| <--- playfield row 5 ---> (level map tile row 27)
 |tttttttttttttttttttt| <--- playfield row 6 ---> (level map tile row 28)
 |tttttttttttttttttttt| <--- playfield row 7 ---> (level map tile row 29)
 |tttttttttttttttttttt| <--- playfield row 8 ---> (level map tile row 30)
 |tttttttttttttttttttt| <--- playfield row 9 ---> (level map tile row 31)
 |ssssssssssssssssssss| <--- scroll row
 |uuuuuuuuuuuuuuuuuuuu| <--- bottom update row

Because we don't know ahead of time which way scrolling will be initiated at
the start we therefore populate both the top update row and the scroll row
during the initial screen draw. This effectively makes the top update row
a pseudo-scroll row for the start.

The direction value is set to DOWN as the default which implies the bottom
update row will be used.

Initial scanwrap buffer fill state:

 |uuuuuuuuuuuuuuuuuuuu| <--- FILLED - level map tile row 21
 |tttttttttttttttttttt| <--- FILLED - level map tile row 22 (display start)
 |tttttttttttttttttttt| <--- FILLED - level map tile row 23
 |tttttttttttttttttttt| <--- FILLED - level map tile row 24
 |tttttttttttttttttttt| <--- FILLED - level map tile row 25
 |tttttttttttttttttttt| <--- FILLED - level map tile row 26
 |tttttttttttttttttttt| <--- FILLED - level map tile row 27
 |tttttttttttttttttttt| <--- FILLED - level map tile row 28
 |tttttttttttttttttttt| <--- FILLED - level map tile row 29
 |tttttttttttttttttttt| <--- FILLED - level map tile row 30
 |tttttttttttttttttttt| <--- FILLED - level map tile row 31 (display end)
 |ssssssssssssssssssss| <--- FILLED - level map tile row 32
 |uuuuuuuuuuuuuuuuuuuu| <--- bottom update row
  |
  v
 ---
  | now one of two things can happen:
 .-.
 | |    ------------------------------------------------------------------------
 | '--> step 2a - immediate move upward
 |
 |      With an immediate move upward from pixel 0 of tile row 22 we have moved
 |      into level map row 21 as the first row displayed on-screen. Since this
 |      was filled into the top update row during the initial draw it is no
 |      problem. The screen address pointer is decremented by 2560 (each line
 |      is 160 bytes and 16 lines for a row) to point to the new row and the
 |      scroll value is set to 15 as we are at speed -1 and have gone back one
 |      line.
 |
 |      Because there was a row change the speed is checked to see if it was
 |      negative. If it was, then the scroll direction is changed to UP which
 |      causes the top update row to used. Note that because of how the scanwrap
 |      buffer works, the top update row is now the last row in the buffer.
 |
 |      |tttttttttttttttttttt| <--- playfield row 0 (display start - at line 15)
 |      |tttttttttttttttttttt| <--- playfield row 1
 |      |tttttttttttttttttttt| <--- playfield row 2
 |      |tttttttttttttttttttt| <--- playfield row 3
 |      |tttttttttttttttttttt| <--- playfield row 4
 |      |tttttttttttttttttttt| <--- playfield row 5
 |      |tttttttttttttttttttt| <--- playfield row 6
 |      |tttttttttttttttttttt| <--- playfield row 7
 |      |tttttttttttttttttttt| <--- playfield row 8
 |      |tttttttttttttttttttt| <--- playfield row 9 (display end - 15 lines)
 |      |ssssssssssssssssssss| <--- fine scroll row (still has valid fill)
 |      |uuuuuuuuuuuuuuuuuuuu| <--- bottom update row
 |      |uuuuuuuuuuuuuuuuuuuu| <--- top update row
 |
 |      The top update row will then continue to be used during the update
 |      intervals as long as there are no row changes, irregardless of
 |      inter-row directional changes due to positive/negative speeds.
 |      ------------------------------------------------------------------------
 |
 |      ------------------------------------------------------------------------
 '----> step 2b - immediate move downward

        If instead of moving up at the start, there was an immediate move
        down, then the situation is only that we have moved 1 line in the same
        row so the direction will stay DOWN and 1 line from the scroll row
        will be visible on the screen. Also, the bottom update row will be used
        until a row change is detected in which case a check will be made to see
        if the speed was positive or negative when the coarse scroll occurred.

        |uuuuuuuuuuuuuuuuuuuu| <--- top update row  (still has valid fill)
        |tttttttttttttttttttt| <--- playfield row 0 (display start - at line 1)
        |tttttttttttttttttttt| <--- playfield row 1
        |tttttttttttttttttttt| <--- playfield row 2
        |tttttttttttttttttttt| <--- playfield row 3
        |tttttttttttttttttttt| <--- playfield row 4
        |tttttttttttttttttttt| <--- playfield row 5
        |tttttttttttttttttttt| <--- playfield row 6
        |tttttttttttttttttttt| <--- playfield row 7
        |tttttttttttttttttttt| <--- playfield row 8
        |tttttttttttttttttttt| <--- playfield row 9
        |ssssssssssssssssssss| <--- scroll row      (display end - 1 line)
        |uuuuuuuuuuuuuuuuuuuu| <--- bottom update
        ------------------------------------------------------------------------


===================
Topic:Speed Changes
===================

Increasing speed from speed 1 may result in an out-of-phase condition due to
the phase jump landing in the middle of the next phase but not exactly at the
start. This out-of-phase condition is corrected using normalization.
~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Normalizing Phase
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Another out-of-phase condition that can result from increasing speeds is one in
which 'gaps' can appear in the update row. These gaps need to be addressed to
continue the seamless illusion of 'infinite' scrolling.

Such gaps only appear if the speed has been increased and after a one-time
mending, the phases will then copy phase blocks to the update row at the new
speed as normal. Note that not every speed increase will cause a gap. Further,
there are 2 slightly different out-of-phase conditions possible, one which will
require 'phase compensation' and the other 'phase completion'.

Both are described below.

========================
Topic:Phase Compensation
========================

Consider the following example to understand how and why gaps could occur that
require phase compensation. The example presents a series of movements possible
in a phase scroll sequence involving speed changes and their outcomes.

----------------------------------------------------------------
step 1 - start

             speed = 1
             phase = 0
        y-position = 0

  .---phase
  .---y-position
  v
| x . . . . . . . . . . . . . . . |

Here the sequence begins at speed 1 and phase is aligned.
The 'x' represents the portion of the update row that is
filled during the phase.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 2 - movement downward

             speed = 1
             phase = 1
        y-position = 1

    .---phase
    .---y-position
    v
| x x . . . . . . . . . . . . . . |

After fine-scrolling 1 line down at speed 1, phase is still
aligned. At this point 2 phase blocks have copied into the
update row.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 3 - speed increase to 4

             speed = 4
             phase = 4
        y-position = 5

    .---previous phase
    |     .---phase
    |     | .---y-position
    v     v v
| x x * * x x x x . . . . . . . . |
      |   |
      '---'
        '---gap

Here the speed has increased to 4 and the y-position is now 5
and the normalized phase is 4 which will result in phase blocks
4-7 being filled. However, phase blocks 2-3 have been skipped
over and this has resulted in a out-of-phase gap represented by
the '*' symbols. These must be identified and filled in along
with the current phase block 4.

This is called 'phase compensation'.

          .---phase
          | .---y-position
          v v
| x x x x x x x x . . . . . . . . |

After phase compensation, the update row is filled and is
in-phase with the new speed.
----------------------------------------------------------------


======================
Topic:Phase Completion
======================

This scenario describes an out-of-phase condition which can occur that
requires 'phase completion'. This can happen when an y-position is near to the
point where a coarse scroll is required when a speed increase happens.

---------------------------------------------------------------------
step 1 - start

             speed = 1
             phase = 13
        y-position = 13

                            .----phase
                            .----y-position
                            v
| x x x x x x x x x x x x x x . . |

Here we start at y-position 13 and phase 13. Phase blocks 0-13
are filled in.
---------------------------------------------------------------------
            |
            v
---------------------------------------------------------------------
step 2 - speed increase to 4

             speed = 4
             phase = 0  (coarse scroll)
        y-position = 17

                            .---previous phase
                            |       .---phase
                            |       | .---y-position
                            v       v v
| x x x x x x x x x x x x x x * * | x x x x . . . . . . . . . . . . |
                              ^   ^
  (screen address 0)          |   | (screen address 2560)
                              '---'
                                |
                                '---gap

Here the speed has increased to 4 and the y-position is now 17.
However, this y-position increase has resulted in two things.
First, it has caused a coarse scroll into a new screen address.
This means the phase is now reset back to 0. It also means the old
update row we were working on filling is now the scroll row and
can be visible on the screen as the fine-scroll continues. We can
see the speed increase has resulted in a out-of-phase gap at the
end of the old update row. This gap will contain invalid tile data
and will be visible as 'garbage' on the screen. This gap must
therefore be filled in along with the normal phase block during
this phase.

This is called 'phase completion'.

                                    .---phase
                                    | .---y-position
                                    v v
| x x x x x x x x x x x x x x x x | x x x x . . . . . . . . . . . . |
  (screen address 0)                (screen address 2560)

After phase completion, the scroll row is corrected and the update
row is filled and in-phase with the new speed.
---------------------------------------------------------------------

================
Topic:Fill Gauge
================

As seen in the previous topics, speed increases can sometimes cause a momentary
out-of-phase condition which must to be corrected to continue the illusion of
infinite scrolling.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Phase Compensation
See Topic:Phase Completion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is also true that inter-row directional changes can occur involving
positive and negative speed changes.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See Topic:Directional Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These inter-row directional changes could lead to a situation where a gap
might appear to exist when in fact due to previous inter-row movement the
phase blocks comprising the gap were actually filled in and valid.

Consider this example sequence:
----------------------------------------------------------------
step 1 - start

             speed = 1
             phase = 7
        y-position = 7

                .----phase
                .----y-position
                v
| x x x x x x x x . . . . . . . . |

Here we start at y-position 7 and phase 7.
Phase blocks 0-7 have been filled in.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 2 - speed change to -1

             speed = -1
             phase = 6
        y-position = 6

              .---phase
              .---y-position
              v
| x x x x x x x o . . . . . . . . |
                ^
                '---phase block still filled and valid

Here the speed is changed to -1 and inter-row movement
occurs upwards which leaves a residual phase block ahead
of the current phase that is nevertheless filled and valid.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 3 - speed change to 2

             speed = 2
             phase = 8
        y-position = 8

                .---phantom gap
                |
                | .----phase
                | .----y-position
                v v
| x x x x x x x o x x . . . . . . |
                ^
                '---phase block still filled and valid

After a speed change to 2 we move up to y-position 8 and
phase 8 which will be detected as leaving a gap between
phase 7 and 8, but in actuality it is a 'phantom' gap as
the phase block is filled and valid in the update row.
----------------------------------------------------------------

Since a primary goal of phase scrolling is to smooth out phase interval work
it is preferable to avoid spending processing time to fill in phantom gaps as
this is wasted cpu cycles and can result in erratic phase timing if many
inter-row movements are done sequentially.

In the above scenario, if we could keep track of how 'full' the update row
was at any point irregardless of positive/negative inter-row directional
changes, then unnecessary phase compensation could be avoided with phantom gaps,
keeping the phase processing smoother and more consistent.

To implement such tracking, phase scrolling uses the concept of a 'fill gauge'.

The fill gauge is a way to monitor the 'fullness' of the update row under
construction. After any row changes due to coarse scrolling the fill gauge is
reset and ready to be raised again as needed.

Let's revisit the previous example scenario, this time with the aid of the
fill gauge. Note that the fill gauge points to the phase block after the highest
phase completed since it represents the fullness of the update row that
includes the *contents* of the highest phase completed.

Example sequence with fill gauge:
----------------------------------------------------------------
step 1 - start

             speed = 1
             phase = 7
        y-position = 7
        fill gauge = 8

                .----phase
                .----y-position
                v
| x x x x x x x x . . . . . . . . |
                  ^
                  '----fill gauge

Here we start at y-position 7 and phase 7.
Phase blocks 0-7 have been filled in and the fill gauge is at 8.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 2 - speed change to -1

             speed = -1
             phase = 6
        y-position = 6
        fill gauge = 8

              .---phase
              .---y-position
              v
| x x x x x x x o . . . . . . . . |
                ^ ^
                | '---fill gauge
                |
                '---phase block still filled and valid

Here the speed is changed to -1 and upwards inter-row
movement occurs which leaves a residual phase block ahead of
the current phase that is nevertheless filled and valid.
The fill gauge stays at phase 8.
----------------------------------------------------------------
            |
            v
----------------------------------------------------------------
step 3 - speed change to 2

             speed = 2
             phase = 8
        y-position = 8
        fill gauge = 8

                .---phantom gap
                |
                | .----phase
                | .----y-position
                v v
| x x x x x x x o x x . . . . . . |
                ^ ^
                | '---fill gauge
                |
                '---phase block still filled and valid

After a speed change to positive 2 we move up to y-position and
phase 8 as before, but the phantom gap now will no longer be
detected as an out-of-phase condition because the fill gauge
will indicate that, in fact, the gap is not real.

Further, since we are at speed 2, the phase interval will fill
in 2 phase blocks and the fill gauge will be updated to reflect
this new 'high water' point.

             speed = 2
             phase = 8
        y-position = 8
        fill gauge = 10

                  .----phase
                  .----y-position
                  v
| x x x x x x x x x x . . . . . . |
                      ^
                      '---fill gauge
----------------------------------------------------------------

As a last note, when the fill gauge is at 16, it indicates the update row
is completely full and no more gap compensation will be needed regardless of
y-position changes as long as we stay in the same playfield row.

end text
